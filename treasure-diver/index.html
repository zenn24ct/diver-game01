<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Treasure Diver</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN";
      overflow: hidden
    }

    body {
      background: linear-gradient(to bottom, #e5f8ff );
      display: flex;
      align-items: center;
      justify-content: center
    }

    .container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 12px;
    }

    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 15px;
      pointer-events: none;
      color: #fff;
      font-weight: 700;
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      font-size: 18px;
      margin-bottom: 10px
    }

    .oxygen-bar {
      width: 200px;
      height: 24px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #fff
    }

    .oxygen-fill {
      height: 100%;
      background: linear-gradient(to right, #ff6b6b, #ffd93d);
      transition: width .15s linear
    }

    .message {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .85);
      padding: 30px 40px;
      border-radius: 15px;
      color: #fff;
      text-align: center;
      pointer-events: auto;
      min-width: 300px;
      backdrop-filter: blur(10px)
    }

    .message h1 {
      font-size: 36px;
      margin-bottom: 15px;
      color: #ffd93d
    }

    .message p {
      font-size: 18px;
      margin-bottom: 20px;
      line-height: 1.6
    }

    .message button {
      padding: 12px 30px;
      font-size: 18px;
      background: linear-gradient(135deg, #c0ffec, #4cffab);
      border: none;
      border-radius: 50px;
      color: #fff;
      cursor: pointer
    }

    .instructions {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, .8);
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, .7)
    }

    @media (max-width:640px) {
      .oxygen-bar {
        width: 150px;
        height: 20px
      }

      .hud-top {
        font-size: 16px
      }

      .message h1 {
        font-size: 28px
      }

      .message p {
        font-size: 16px
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="hud-top">
        <div>ğŸ’ å®: <span id="treasure">0</span></div>
        <div>æ·±åº¦: <span id="depth">0</span>m</div>
      </div>
      <div class="oxygen-bar">
        <div class="oxygen-fill" id="oxygenFill"></div>
      </div>
    </div>
    <div class="instructions">â† â†’ / A D ã§ç§»å‹• | â†‘ / W ã§æµ®ä¸Š | ã‚¿ãƒƒãƒ—ã§æ“ä½œ</div>
  </div>

  <script>
    /* Treasure Diver â€” é…¸ç´ ã‚¢ã‚¤ãƒ†ãƒ ãƒ»æµ®ä¸Šæ¤œå‡ºãƒ»æœ€çµ‚ã‚¹ã‚³ã‚¢ä¿®æ­£ç‰ˆ */

    const CFG = {
      baseWidth: 480, baseHeight: 720,
      player: { w: 30, h: 40, speed: 200, sinkSpeed: 80, swimUpSpeed: 180 },
      oxygen: { max: 60 }, // ç§’
      treasure: { spawnInterval: 1200, size: 20, scoreBase: 10, depthBonus: 2 },
      danger: { spawnInterval: 2500, size: 35, speed: 60 },
      surface: { y: 100 },
      oxygenItem: { spawnInterval: 8000, size: 22, bonus: 10 } // é…¸ç´ ã‚¢ã‚¤ãƒ†ãƒ : 8ç§’æ¯ã«æ¹§ãï¼ˆãƒŸãƒ‹ãƒãƒ ï¼‰
    };

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let W = 0, H = 0, scale = 1;

    const treasureEl = document.getElementById('treasure');
    const depthEl = document.getElementById('depth');
    const oxygenFillEl = document.getElementById('oxygenFill');

    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const maxW = window.innerWidth, maxH = window.innerHeight;
      const targetRatio = CFG.baseWidth / CFG.baseHeight;
      let cssW, cssH;
      if (maxW / maxH > targetRatio) { cssH = maxH; cssW = Math.round(cssH * targetRatio); }
      else { cssW = maxW; cssH = Math.round(cssW / targetRatio); }
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
      canvas.width = Math.round(cssW * DPR); canvas.height = Math.round(cssH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      W = cssW; H = cssH; scale = W / CFG.baseWidth;
    }
    window.addEventListener('resize', resize);

    // --- ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ---
    let gameState = 'playing';
    let score = 0, collectedTreasure = 0;
    let oxygen = CFG.oxygen.max; // æ®‹ã‚Šç§’æ•°
    let cameraY = 0;
    const player = { x: 0, y: 0, w: 0, h: 0, vx: 0, vy: 0 };
    let treasures = [], dangers = [], particles = [], oxygenItems = [], floatTexts = [];
    let treasureSpawnTimer = 0, dangerSpawnTimer = 0, oxygenSpawnTimer = 0, lastTime = 0;
    const input = { left: false, right: false, up: false };
    let prevPlayerY = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const randFloat = (a, b) => Math.random() * (b - a) + a;
    function rectsOverlap(r1, r2) { return !(r1.x + r1.w <= r2.x || r1.x >= r2.x + r2.w || r1.y + r1.h <= r2.y || r1.y >= r2.y + r2.h); }

    class Bubble {
      constructor(x, y, color = 'rgba(255,255,255,0.6)') { this.x = x; this.y = y; this.size = randFloat(2, 5); this.speedY = randFloat(-40, -80); this.speedX = randFloat(-20, 20); this.life = 1; this.color = color; }
      update(dt) { this.x += this.speedX * dt; this.y += this.speedY * dt; this.life -= dt * 0.8; }
      draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
    }

    // æµ®å‹•ãƒ†ã‚­ã‚¹ãƒˆï¼ˆ+10s ç­‰ï¼‰
    class FloatText {
      constructor(x, y, text, ttl = 1.0) { this.x = x; this.y = y; this.text = text; this.ttl = ttl; this.life = ttl; }
      update(dt) { this.y -= 30 * dt; this.life -= dt; }
      draw() { if (this.life <= 0) return; ctx.globalAlpha = Math.max(0, this.life / this.ttl); ctx.font = `${14 * scale}px sans-serif`; ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; }
    }

    function spawnTreasure() {
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      const depthInMeters = Math.floor(depth / scale);
      const value = CFG.treasure.scoreBase + Math.floor(depthInMeters / 100) * CFG.treasure.depthBonus;
      treasures.push({ x: randFloat(0, W - CFG.treasure.size * scale), y: player.y + randFloat(H * 0.3, H * 0.8), w: CFG.treasure.size * scale, h: CFG.treasure.size * scale, value, wobble: Math.random() * Math.PI * 2 });
    }

    function spawnDanger() {
      const fromLeft = Math.random() < 0.5;
      const dir = fromLeft ? 1 : -1;
      dangers.push({ x: fromLeft ? -CFG.danger.size * scale : W + CFG.danger.size * scale, y: player.y + randFloat(H * 0.2, H * 0.7), w: CFG.danger.size * scale, h: CFG.danger.size * scale, vx: dir * CFG.danger.speed * scale, tentacles: Math.random() * Math.PI * 2 });
    }

    function spawnOxygenItem() {
      oxygenItems.push({ x: randFloat(20, W - 20), y: player.y + randFloat(H * 0.3, H * 0.8), w: CFG.oxygenItem.size * scale, h: CFG.oxygenItem.size * scale, wobble: Math.random() * Math.PI * 2 });
    }

    // update: é…¸ç´ ã¯ç§’ã§æ¸›ã‚‹ï¼ˆdtï¼‰
    function update(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dtMs = Math.min(50, timestamp - lastTime);
      const dt = dtMs / 1000;
      lastTime = timestamp;

      if (gameState !== 'playing') { draw(); requestAnimationFrame(update); return; }

      prevPlayerY = player.y;

      // ç§»å‹•
      const dir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
      player.vx = dir * CFG.player.speed * scale;
      player.x += player.vx * dt;
      player.x = clamp(player.x, 0, W - player.w);

      // æµ®ä¸Šãƒ»æ²ˆä¸‹
      player.vy = input.up ? -CFG.player.swimUpSpeed * scale : CFG.player.sinkSpeed * scale;
      player.y += player.vy * dt;

      // æ°´é¢ï¼š**ä¸‹ã‹ã‚‰ä¸Šã«æ¨ªåˆ‡ã£ãŸç¬é–“**ã‚’æ¤œå‡ºã—ã¦æµ®ä¸ŠæˆåŠŸå‡¦ç†ï¼ˆprev > surface && now <= surfaceï¼‰
      const surfaceY = CFG.surface.y * scale;
      if (player.y <= surfaceY) {
        if (prevPlayerY > surfaceY && collectedTreasure > 0) {
          score += collectedTreasure;
          // reset collectedTreasure and UI
          collectedTreasure = 0;
          treasureEl.textContent = '0';
          showMessage('surfaced');
        }
        player.y = surfaceY;
      }

      // ã‚«ãƒ¡ãƒ©
      const targetCam = Math.max(0, player.y - H * 0.3);
      cameraY += (targetCam - cameraY) * 0.1;

      // === é…¸ç´ ï¼ˆç°¡æ½”ï¼‰ ===
      oxygen -= dt; // 1ç§’ã§1æ¸›ã‚‹
      if (oxygen <= 0) {
        oxygen = 0;
        // æœ€çµ‚ã‚¹ã‚³ã‚¢ã«å›åæ¸ˆã¿ã®å®ã‚‚å«ã‚ã¦è¡¨ç¤º
        gameState = 'gameover';
        showMessage('gameover');
      }
      oxygenFillEl.style.width = (oxygen / CFG.oxygen.max * 100) + '%';

      // æ·±åº¦è¡¨ç¤ºï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«æ›ç®—ï¼‰
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      depthEl.textContent = Math.floor(depth / scale);

      // ã‚¹ãƒãƒ¼ãƒ³ï¼šå®
      treasureSpawnTimer += dtMs;
      if (treasureSpawnTimer >= CFG.treasure.spawnInterval) { treasureSpawnTimer = 0; spawnTreasure(); }

      // ã‚¹ãƒãƒ¼ãƒ³ï¼šå±é™ºï¼ˆæ·±åº¦50mä»¥ä¸Šï¼‰
      const depthMeters = Math.floor(depth / scale);
      if (depthMeters >= 50) { dangerSpawnTimer += dtMs; if (dangerSpawnTimer >= CFG.danger.spawnInterval) { dangerSpawnTimer = 0; spawnDanger(); } }

      // ã‚¹ãƒãƒ¼ãƒ³ï¼šé…¸ç´ ã‚¢ã‚¤ãƒ†ãƒ 
      oxygenSpawnTimer += dtMs;
      if (oxygenSpawnTimer >= CFG.oxygenItem.spawnInterval) { oxygenSpawnTimer = 0; spawnOxygenItem(); }

      // å®å–å¾—
      treasures.forEach(t => {
        t.wobble += dt * 3;
        if (rectsOverlap(player, t)) {
          collectedTreasure += t.value;
          treasureEl.textContent = collectedTreasure;
          t.collected = true;
          for (let i = 0; i < 8; i++) particles.push(new Bubble(t.x + t.w / 2, t.y + t.h / 2, '#ffd93d'));
        }
      });
      treasures = treasures.filter(t => !t.collected && t.y > cameraY - 100 && t.y < cameraY + H + 100);

      // é…¸ç´ ã‚¢ã‚¤ãƒ†ãƒ å–å¾—
      oxygenItems.forEach(o => {
        o.wobble += dt * 3;
        if (rectsOverlap(player, o)) {
          oxygen = clamp(oxygen + CFG.oxygenItem.bonus, 0, CFG.oxygen.max);
          floatTexts.push(new FloatText(player.x + player.w / 2, player.y, `+${CFG.oxygenItem.bonus}s`, 1.0));
          o.collected = true;
          for (let i = 0; i < 6; i++) particles.push(new Bubble(o.x + o.w / 2, o.y + o.h / 2, 'rgba(173,216,230,0.9)'));
        }
      });
      oxygenItems = oxygenItems.filter(o => !o.collected && o.y > cameraY - 100 && o.y < cameraY + H + 100);

      // å±é™ºç‰©æ›´æ–°
      dangers.forEach(d => { d.x += d.vx * dt; d.tentacles += dt * 4; if (rectsOverlap(player, d)) { gameState = 'gameover'; showMessage('gameover'); } });
      dangers = dangers.filter(d => d.x > -100 && d.x < W + 100 && d.y > cameraY - 100 && d.y < cameraY + H + 100);

      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
      particles.forEach(p => p.update(dt));
      particles = particles.filter(p => p.life > 0);
      if (Math.random() < 0.3) particles.push(new Bubble(player.x + player.w / 2, player.y + player.h));

      // ãƒ•ãƒ­ãƒ¼ãƒˆãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
      floatTexts.forEach(t => t.update(dt));
      floatTexts = floatTexts.filter(t => t.life > 0);

      draw();
      requestAnimationFrame(update);
    }

    function draw() {
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      const depthRatio = H ? Math.min(1, depth / (H * 3)) : 0;
      const topAlpha = Math.max(0.5, 1 - depthRatio * 0.5);
      const bottomAlpha = Math.max(0.7, 1 - depthRatio * 0.3);
      const gradient = ctx.createLinearGradient(0, 0, 0, H);
      gradient.addColorStop(0, `rgba(135,206,235,${topAlpha})`);
      gradient.addColorStop(1, `rgba(30,58,95,${bottomAlpha})`);
      ctx.fillStyle = gradient; ctx.fillRect(0, 0, W, H);

      ctx.save(); ctx.translate(0, -cameraY);

      // æ°´é¢ãƒ©ã‚¤ãƒ³
      ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(0, CFG.surface.y * scale); ctx.lineTo(W, CFG.surface.y * scale); ctx.stroke();
      ctx.fillStyle = 'rgba(135,206,235,0.3)'; ctx.fillRect(0, 0, W, CFG.surface.y * scale);

      // treasures
      treasures.forEach(t => {
        const wobble = Math.sin(t.wobble) * 3;
        ctx.fillStyle = '#ffd93d'; ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(t.x + t.w / 2, t.y + wobble);
        ctx.lineTo(t.x + t.w, t.y + t.h / 2 + wobble); ctx.lineTo(t.x + t.w / 2, t.y + t.h + wobble);
        ctx.lineTo(t.x, t.y + t.h / 2 + wobble); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.font = `${10 * scale}px sans-serif`; ctx.textAlign = 'center';
        ctx.fillText(t.value, t.x + t.w / 2, t.y + t.h / 2 + wobble + 4);
      });

      // oxygen items
      oxygenItems.forEach(o => {
        const wobble = Math.sin(o.wobble) * 3;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(173,216,230,0.9)'; ctx.strokeStyle = 'rgba(100,160,200,0.9)'; ctx.lineWidth = 2;
        ctx.arc(o.x + o.w / 2, o.y + wobble, o.w / 2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.font = `${12 * scale}px sans-serif`; ctx.textAlign = 'center';
        ctx.fillText(`+${CFG.oxygenItem.bonus}s`, o.x + o.w / 2, o.y + wobble + 4);
      });

      // dangers
      dangers.forEach(d => {
        ctx.fillStyle = 'rgba(255,107,107,0.7)'; ctx.beginPath();
        ctx.arc(d.x + d.w / 2, d.y + d.h / 3, d.w / 2, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,107,107,0.5)'; ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          const xOff = (i - 1.5) * d.w / 4; const wave = Math.sin(d.tentacles + i) * 5;
          ctx.beginPath(); ctx.moveTo(d.x + d.w / 2 + xOff, d.y + d.h / 3); ctx.lineTo(d.x + d.w / 2 + xOff + wave, d.y + d.h); ctx.stroke();
        }
      });

      particles.forEach(p => p.draw());

      // player
      ctx.fillStyle = '#ffe6ff'; ctx.strokeStyle = '#ff99ff'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.ellipse(player.x + player.w / 2, player.y + player.h / 2, player.w / 2, player.h / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#ff0080'; ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 3, player.w / 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(200,230,255,0.6)'; ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 3, player.w / 4, 0, Math.PI * 2); ctx.fill();
      const finY = player.y + player.h * 0.8;
      ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.2, finY); ctx.lineTo(player.x, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.3, finY); ctx.fill();
      ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.8, finY); ctx.lineTo(player.x + player.w, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.7, finY); ctx.fill();

      // float texts
      floatTexts.forEach(t => t.draw());

      ctx.restore();
    }

    function showMessage(type) {
      const existing = document.querySelector('.message'); if (existing) existing.remove();
      const msg = document.createElement('div'); msg.className = 'message';
      if (type === 'gameover') {
        // æœ€çµ‚ã‚¹ã‚³ã‚¢ã«å›åæ¸ˆã¿ã®å®ã‚‚å«ã‚ã¦è¡¨ç¤ºï¼ˆã¾ã ãƒãƒ³ã‚¯ã—ã¦ã„ãªã„åˆ†ã‚’åŠ ãˆã‚‹ï¼‰
        const finalScore = score + collectedTreasure;
        msg.innerHTML = `<h1>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</h1><p>æœ€çµ‚ã‚¹ã‚³ã‚¢: ${finalScore}ç‚¹</p><p>é…¸ç´ ãŒå°½ãã¾ã—ãŸ...</p><button onclick="restart()">ã‚‚ã†ä¸€åº¦</button>`;
      } else if (type === 'surfaced') {
        msg.innerHTML = `<h1>æµ®ä¸ŠæˆåŠŸï¼</h1><p>ç²å¾—: ${score}ç‚¹</p><p>åˆè¨ˆã‚¹ã‚³ã‚¢: ${score}ç‚¹</p><button onclick="continueGame()">å†ã³æ½œã‚‹</button>`;
      }
      document.body.appendChild(msg);
    }

    // å…¥åŠ›
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
      if (e.key === 'ArrowUp' || e.key === 'w') input.up = true;
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
      if (e.key === 'ArrowUp' || e.key === 'w') input.up = false;
    });

    canvas.addEventListener('pointerdown', (e) => {
      const r = canvas.getBoundingClientRect();
      const x = e.clientX - r.left, y = e.clientY - r.top;
      if (y < r.height / 3) input.up = true;
      else if (x < r.width / 2) input.left = true;
      else input.right = true;
    });
    canvas.addEventListener('pointerup', () => { input.left = false; input.right = false; input.up = false; });
    canvas.addEventListener('pointercancel', () => { input.left = false; input.right = false; input.up = false; });

    function restart() {
      gameState = 'playing'; score = 0; collectedTreasure = 0; oxygen = CFG.oxygen.max; cameraY = 0;
      treasures = []; dangers = []; particles = []; oxygenItems = []; floatTexts = [];
      treasureSpawnTimer = 0; dangerSpawnTimer = 0; oxygenSpawnTimer = 0; lastTime = 0;
      player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
      treasureEl.textContent = '0'; depthEl.textContent = '0'; oxygenFillEl.style.width = '100%';
      const m = document.querySelector('.message'); if (m) m.remove(); requestAnimationFrame(update);
    }

    function continueGame() {
      // æµ®ä¸ŠæˆåŠŸå¾Œã«å†ã³æ½œã‚‹ï¼ˆç¾åœ¨ã¯ã‚¹ã‚³ã‚¢ã¯æ—¢ã«åˆç®—æ¸ˆã¿ï¼‰
      gameState = 'playing'; collectedTreasure = 0; oxygen = CFG.oxygen.max; player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
      treasureEl.textContent = '0'; oxygenFillEl.style.width = '100%'; const m = document.querySelector('.message'); if (m) m.remove(); lastTime = 0; requestAnimationFrame(update);
    }

    function init() {
      resize();
      player.w = CFG.player.w * scale; player.h = CFG.player.h * scale;
      player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale;
      treasureEl.textContent = '0'; depthEl.textContent = '0';
      oxygenFillEl.style.width = (oxygen / CFG.oxygen.max * 100) + '%';
      requestAnimationFrame(update);
    }
    init();
  </script>
</body>

</html>