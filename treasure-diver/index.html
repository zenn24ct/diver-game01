<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Treasure Diver</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  html,body{
    height:100%;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN";
    overflow:hidden;
  }
  body{
    background:linear-gradient(to bottom, #87CEEB 0%, #1e3a5f 100%);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .container{
    width:100%;
    height:100%;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{
    max-width:100%;
    max-height:100%;
    border-radius:12px;
    box-shadow:0 10px 40px rgba(0,0,0,.4);
  }
  .hud{
    position:absolute;
    top:0;
    left:0;
    width:100%;
    padding:15px;
    pointer-events:none;
    color:#fff;
    font-weight:700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
  }
  .hud-top{
    display:flex;
    justify-content:space-between;
    font-size:18px;
    margin-bottom:10px;
  }
  .oxygen-bar{
    width:200px;
    height:24px;
    background:rgba(0,0,0,0.5);
    border-radius:12px;
    overflow:hidden;
    border:2px solid #fff;
  }
  .oxygen-fill{
    height:100%;
    background:linear-gradient(to right, #ff6b6b, #ffd93d);
    transition:width 0.3s;
  }
  .message{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.85);
    padding:30px 40px;
    border-radius:15px;
    color:#fff;
    text-align:center;
    pointer-events:auto;
    min-width:300px;
    backdrop-filter:blur(10px);
  }
  .message h1{
    font-size:36px;
    margin-bottom:15px;
    color:#ffd93d;
  }
  .message p{
    font-size:18px;
    margin-bottom:20px;
    line-height:1.6;
  }
  .message button{
    padding:12px 30px;
    font-size:18px;
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border:none;
    border-radius:50px;
    color:white;
    cursor:pointer;
    transition:transform 0.2s;
  }
  .message button:hover{
    transform:scale(1.05);
  }
  .instructions{
    position:absolute;
    bottom:15px;
    left:50%;
    transform:translateX(-50%);
    color:rgba(255,255,255,0.8);
    font-size:14px;
    text-align:center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    pointer-events:none;
  }
  @media (max-width:640px){
    .oxygen-bar{ width:150px; height:20px; }
    .hud-top{ font-size:16px; }
    .message h1{ font-size:28px; }
    .message p{ font-size:16px; }
  }
</style>
</head>
<body>
  <div class="container">
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="hud-top">
        <div>üíé ÂÆù: <span id="treasure">0</span></div>
        <div>Ê∑±Â∫¶: <span id="depth">0</span>m</div>
      </div>
      <div class="oxygen-bar">
        <div class="oxygen-fill" id="oxygenFill"></div>
      </div>
    </div>
    <div class="instructions">‚Üê ‚Üí / A D „ÅßÁßªÂãï | ‚Üë / W „ÅßÊµÆ‰∏ä | „Çø„ÉÉ„Éó„ÅßÊìç‰Ωú</div>
  </div>

<script>
/* 
  Treasure Diver - Êµ∑Â∫ïÂÆùÊé¢„Åó„Ç≤„Éº„É†ÔºàÈÖ∏Á¥†Ê∂àË≤ª„ÇíÁ∑©„ÇÑ„Åã„Å´Ë™øÊï¥Ê∏à„ÅøÔºâ
*/

// =====================================
// ÂÆöÊï∞Ë®≠ÂÆöÔºàÈÖ∏Á¥†Ê∂àË≤ª„ÇíË™øÊï¥„Åó„Åæ„Åó„ÅüÔºâ
// =====================================
const CFG = {
  baseWidth: 480,
  baseHeight: 720,
  player: {
    w: 30,
    h: 40,
    speed: 200,
    sinkSpeed: 80,
    swimUpSpeed: 180,
  },
  oxygen: {
    max: 100,
    // ‚Üê „Åì„Åì„ÇíÂ∞è„Åï„Åè„Åó„Å¶ÈÖ∏Á¥†Ê∂àË≤ª„ÇíÈÅÖ„Åè„Åó„Åü
    consumeRate: 2,       // ‰ª•Ââç„ÅØ 8„ÄÇË°®Èù¢„ÅßÁ¥Ñ50ÁßíÊåÅ„Å§ÁõÆÂÆâÔºà100 / 2 = 50sÔºâ
    // Ê∑±Â∫¶„Å´„Çà„ÇãÂ¢óÂä†„ÇíÁ∑©„ÇÑ„Åã„Å´
    depthMultiplier: 0.007
  },
  treasure: {
    spawnInterval: 1200,
    size: 20,
    scoreBase: 10,
    depthBonus: 2
  },
  danger: {
    spawnInterval: 2500,
    size: 35,
    speed: 60
  },
  surface: {
    y: 100
  }
};

// =====================================
// „Ç≠„É£„É≥„Éê„ÇπË®≠ÂÆöÔºàÁúÅÁï•„Åõ„Åö„Åù„ÅÆ„Åæ„ÅæÔºâ
// =====================================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

let DPR = Math.max(1, window.devicePixelRatio || 1);
let W = 0, H = 0, scale = 1;

const treasureEl = document.getElementById('treasure');
const depthEl = document.getElementById('depth');
const oxygenFillEl = document.getElementById('oxygenFill');

function resize() {
  DPR = Math.max(1, window.devicePixelRatio || 1);
  const maxW = window.innerWidth;
  const maxH = window.innerHeight;
  const targetRatio = CFG.baseWidth / CFG.baseHeight;
  let cssW, cssH;
  const screenRatio = maxW / maxH;
  if (screenRatio > targetRatio) {
    cssH = maxH;
    cssW = Math.round(cssH * targetRatio);
  } else {
    cssW = maxW;
    cssH = Math.round(cssW / targetRatio);
  }
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  W = cssW;
  H = cssH;
  scale = W / CFG.baseWidth;
}
window.addEventListener('resize', resize);

// =====================================
// „Ç≤„Éº„É†Áä∂ÊÖãÔºàÂêå„ÅòÔºâ
// =====================================
let gameState = 'playing';
let score = 0;
let collectedTreasure = 0;
let oxygen = CFG.oxygen.max;
let cameraY = 0;

const player = { x: 0, y: 0, w: 0, h: 0, vx: 0, vy: 0 };
let treasures = [], dangers = [], particles = [];
let treasureSpawnTimer = 0, dangerSpawnTimer = 0, lastTime = 0;
const input = { left:false, right:false, up:false };

const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const rand = (min, max) => Math.floor(Math.random() * (min - max + 1)) + min;
const randFloat = (min, max) => Math.random() * (max - min) + min;

function rectsOverlap(r1, r2) {
  return !(r1.x + r1.w <= r2.x || 
           r1.x >= r2.x + r2.w || 
           r1.y + r1.h <= r2.y || 
           r1.y >= r2.y + r2.h);
}

class Bubble {
  constructor(x, y, color = 'rgba(255,255,255,0.6)') {
    this.x = x; this.y = y; this.size = randFloat(2,5);
    this.speedY = randFloat(-40, -80); this.speedX = randFloat(-20,20);
    this.life = 1; this.color = color;
  }
  update(dt){ this.x += this.speedX * dt; this.y += this.speedY * dt; this.life -= dt * 0.8; }
  draw(){ ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }
}

function spawnTreasure() {
  const depth = Math.max(0, player.y - CFG.surface.y * scale);
  const depthInMeters = Math.floor(depth / scale);
  const value = CFG.treasure.scoreBase + Math.floor(depthInMeters / 100) * CFG.treasure.depthBonus;
  treasures.push({
    x: randFloat(0, W - CFG.treasure.size * scale),
    y: player.y + randFloat(H * 0.3, H * 0.8),
    w: CFG.treasure.size * scale,
    h: CFG.treasure.size * scale,
    value, wobble: Math.random() * Math.PI * 2
  });
}

function spawnDanger() {
  const fromLeft = Math.random() < 0.5;
  const direction = fromLeft ? 1 : -1;
  dangers.push({
    x: fromLeft ? -CFG.danger.size * scale : W + CFG.danger.size * scale,
    y: player.y + randFloat(H * 0.2, H * 0.7),
    w: CFG.danger.size * scale,
    h: CFG.danger.size * scale,
    vx: direction * CFG.danger.speed * scale,
    tentacles: Math.random() * Math.PI * 2
  });
}

function update(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dtMs = Math.min(50, timestamp - lastTime);
  const dt = dtMs / 1000;
  lastTime = timestamp;
  if (gameState !== 'playing') { draw(); requestAnimationFrame(update); return; }

  const moveDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
  player.vx = moveDir * CFG.player.speed * scale;
  player.x += player.vx * dt;
  player.x = clamp(player.x, 0, W - player.w);

  if (input.up) player.vy = -CFG.player.swimUpSpeed * scale;
  else player.vy = CFG.player.sinkSpeed * scale;
  player.y += player.vy * dt;

  if (player.y <= CFG.surface.y * scale) {
    if (collectedTreasure > 0) {
      score += collectedTreasure;
      showMessage('surfaced');
    }
    player.y = CFG.surface.y * scale;
  }

  const targetCameraY = Math.max(0, player.y - H * 0.3);
  cameraY += (targetCameraY - cameraY) * 0.1;

  // --- ÈÖ∏Á¥†Ê∂àË≤ªÔºà„Åì„Åì„ÇíÁ∑©„ÇÑ„Åã„Å´Ôºâ ---
  const depth = Math.max(0, player.y - CFG.surface.y * scale);
  // depthFactor „ÅØ 1 + depth(m) * depthMultiplier
  const depthFactor = 1 + (depth / scale) * CFG.oxygen.depthMultiplier;
  oxygen -= CFG.oxygen.consumeRate * depthFactor * dt;
  if (oxygen <= 0) {
    oxygen = 0;
    gameState = 'gameover';
    showMessage('gameover');
  }
  oxygenFillEl.style.width = (oxygen / CFG.oxygen.max * 100) + '%';
  // --------------------------------------

  const depthInMeters = Math.floor(Math.max(0, depth) / scale);
  depthEl.textContent = depthInMeters;

  treasureSpawnTimer += dtMs;
  if (treasureSpawnTimer >= CFG.treasure.spawnInterval) {
    treasureSpawnTimer = 0;
    spawnTreasure();
  }

  if (depthInMeters >= 50) {
    dangerSpawnTimer += dtMs;
    if (dangerSpawnTimer >= CFG.danger.spawnInterval) {
      dangerSpawnTimer = 0;
      spawnDanger();
    }
  }

  treasures.forEach(t => {
    t.wobble += dt * 3;
    if (rectsOverlap(player, t)) {
      collectedTreasure += t.value;
      treasureEl.textContent = collectedTreasure;
      t.collected = true;
      for (let i = 0; i < 8; i++) particles.push(new Bubble(t.x + t.w/2, t.y + t.h/2, '#ffd93d'));
    }
  });
  treasures = treasures.filter(t => !t.collected && t.y > cameraY - 100 && t.y < cameraY + H + 100);

  dangers.forEach(d => {
    d.x += d.vx * dt;
    d.tentacles += dt * 4;
    if (rectsOverlap(player, d)) {
      gameState = 'gameover';
      showMessage('gameover');
    }
  });
  dangers = dangers.filter(d => d.x > -100 && d.x < W + 100 && d.y > cameraY - 100 && d.y < cameraY + H + 100);

  particles.forEach(p => p.update(dt));
  particles = particles.filter(p => p.life > 0);

  if (Math.random() < 0.3) particles.push(new Bubble(player.x + player.w/2, player.y + player.h));

  draw();
  requestAnimationFrame(update);
}

function draw() {
  const depth = Math.max(0, player.y - CFG.surface.y * scale);
  const depthRatio = (H > 0) ? Math.min(1, depth / (H * 3)) : 0;
  const topAlpha = Math.max(0.5, 1 - depthRatio * 0.5);
  const bottomAlpha = Math.max(0.7, 1 - depthRatio * 0.3);
  const topColor = `rgba(135, 206, 235, ${topAlpha})`;
  const bottomColor = `rgba(30, 58, 95, ${bottomAlpha})`;
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, topColor);
  gradient.addColorStop(1, bottomColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  ctx.translate(0, -cameraY);

  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, CFG.surface.y * scale);
  ctx.lineTo(W, CFG.surface.y * scale);
  ctx.stroke();

  ctx.fillStyle = 'rgba(135, 206, 235, 0.3)';
  ctx.fillRect(0, 0, W, CFG.surface.y * scale);

  treasures.forEach(t => {
    const wobbleOffset = Math.sin(t.wobble) * 3;
    ctx.fillStyle = '#ffd93d';
    ctx.strokeStyle = '#ff8c00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(t.x + t.w/2, t.y + wobbleOffset);
    ctx.lineTo(t.x + t.w, t.y + t.h/2 + wobbleOffset);
    ctx.lineTo(t.x + t.w/2, t.y + t.h + wobbleOffset);
    ctx.lineTo(t.x, t.y + t.h/2 + wobbleOffset);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = `${10 * scale}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(t.value, t.x + t.w/2, t.y + t.h/2 + wobbleOffset + 4);
  });

  dangers.forEach(d => {
    ctx.fillStyle = 'rgba(255, 107, 107, 0.7)';
    ctx.beginPath();
    ctx.arc(d.x + d.w/2, d.y + d.h/3, d.w/2, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
      const xOffset = (i - 1.5) * d.w/4;
      const wave = Math.sin(d.tentacles + i) * 5;
      ctx.beginPath();
      ctx.moveTo(d.x + d.w/2 + xOffset, d.y + d.h/3);
      ctx.lineTo(d.x + d.w/2 + xOffset + wave, d.y + d.h);
      ctx.stroke();
    }
  });

  particles.forEach(p => p.draw());

  ctx.fillStyle = '#4a90e2';
  ctx.strokeStyle = '#2c5aa0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(player.x + player.w/2, player.y + player.h/2, player.w/2, player.h/2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(player.x + player.w/2, player.y + player.h/3, player.w/3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = 'rgba(200, 230, 255, 0.6)';
  ctx.beginPath();
  ctx.arc(player.x + player.w/2, player.y + player.h/3, player.w/4, 0, Math.PI * 2);
  ctx.fill();

  const finY = player.y + player.h * 0.8;
  ctx.fillStyle = '#e74c3c';
  ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.2, finY); ctx.lineTo(player.x, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.3, finY); ctx.fill();
  ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.8, finY); ctx.lineTo(player.x + player.w, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.7, finY); ctx.fill();

  ctx.restore();
}

function showMessage(type) {
  const existing = document.querySelector('.message');
  if (existing) existing.remove();
  const msg = document.createElement('div');
  msg.className = 'message';
  if (type === 'gameover') {
    msg.innerHTML = `<h1>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1><p>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}ÁÇπ</p><p>ÈÖ∏Á¥†„ÅåÂ∞Ω„Åç„Åæ„Åó„Åü...</p><button onclick="restart()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>`;
  } else if (type === 'surfaced') {
    msg.innerHTML = `<h1>ÊµÆ‰∏äÊàêÂäüÔºÅ</h1><p>Áç≤Âæó: ${collectedTreasure}ÁÇπ</p><p>ÂêàË®à„Çπ„Ç≥„Ç¢: ${score}ÁÇπ</p><button onclick="continueGame()">ÂÜç„Å≥ÊΩú„Çã</button>`;
  }
  document.body.appendChild(msg);
}

window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = true;
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') input.up = true;
});
window.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = false;
  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') input.up = false;
});

canvas.addEventListener('pointerdown', (e) => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;
  if (y < r.height / 3) input.up = true;
  else if (x < r.width / 2) input.left = true;
  else input.right = true;
});
canvas.addEventListener('pointerup', () => { input.left = false; input.right = false; input.up = false; });
canvas.addEventListener('pointercancel', () => { input.left = false; input.right = false; input.up = false; });

function restart() {
  gameState = 'playing'; score = 0; collectedTreasure = 0; oxygen = CFG.oxygen.max; cameraY = 0;
  treasures = []; dangers = []; particles = []; treasureSpawnTimer = 0; dangerSpawnTimer = 0;
  player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
  treasureEl.textContent = '0'; depthEl.textContent = '0'; oxygenFillEl.style.width = '100%';
  const msg = document.querySelector('.message'); if (msg) msg.remove();
  lastTime = 0; requestAnimationFrame(update);
}

function continueGame() {
  gameState = 'playing'; collectedTreasure = 0; oxygen = CFG.oxygen.max;
  player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
  treasureEl.textContent = '0'; oxygenFillEl.style.width = '100%';
  const msg = document.querySelector('.message'); if (msg) msg.remove();
  lastTime = 0;
}

function init() {
  resize();
  player.w = CFG.player.w * scale; player.h = CFG.player.h * scale;
  player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale;
  treasureEl.textContent = '0'; depthEl.textContent = '0';
  requestAnimationFrame(update);
}
init();
</script>
</body>
</html>
