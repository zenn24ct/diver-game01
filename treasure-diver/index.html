<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Treasure Diver</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN";
      overflow: hidden
    }

    body {
      background: linear-gradient(to bottom, #87CEEB 0%, #1e3a5f 100%);
      display: flex;
      align-items: center;
      justify-content: center
    }

    .container {
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center
    }

    canvas {
      max-width: 100%;
      max-height: 100%;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .4)
    }

    .hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 15px;
      pointer-events: none;
      color: #fff;
      font-weight: 700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, .7)
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      font-size: 18px;
      margin-bottom: 10px
    }

    .oxygen-bar {
      width: 200px;
      height: 24px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #fff
    }

    .oxygen-fill {
      height: 100%;
      background: linear-gradient(to right, #ff6b6b, #ffd93d);
      transition: width .15s linear
    }

    .message {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .85);
      padding: 30px 40px;
      border-radius: 15px;
      color: #fff;
      text-align: center;
      pointer-events: auto;
      min-width: 300px;
      backdrop-filter: blur(10px)
    }

    .message h1 {
      font-size: 36px;
      margin-bottom: 15px;
      color: #ffd93d
    }

    .message p {
      font-size: 18px;
      margin-bottom: 20px;
      line-height: 1.6
    }

    .message button {
      padding: 12px 30px;
      font-size: 18px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      border-radius: 50px;
      color: #fff;
      cursor: pointer
    }

    .instructions {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, .8);
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, .7)
    }

    @media (max-width:640px) {
      .oxygen-bar {
        width: 150px;
        height: 20px
      }

      .hud-top {
        font-size: 16px
      }

      .message h1 {
        font-size: 28px
      }

      .message p {
        font-size: 16px
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <canvas id="c"></canvas>
    <div class="hud">
      <div class="hud-top">
        <div>üíé ÂÆù: <span id="treasure">0</span></div>
        <div>Ê∑±Â∫¶: <span id="depth">0</span>m</div>
      </div>
      <div class="oxygen-bar">
        <div class="oxygen-fill" id="oxygenFill"></div>
      </div>
    </div>
    <div class="instructions">‚Üê ‚Üí / A D „ÅßÁßªÂãï | ‚Üë / W „ÅßÊµÆ‰∏ä | „Çø„ÉÉ„Éó„ÅßÊìç‰Ωú</div>
  </div>

  <script>
    /* Treasure Diver ‚Äî ÈÖ∏Á¥†„ÇíÁßí„ÅßÊâ±„ÅÜ„Ç∑„É≥„Éó„É´Áâà */

    const CFG = {
      baseWidth: 480, baseHeight: 720,
      player: { w: 30, h: 40, speed: 200, sinkSpeed: 80, swimUpSpeed: 180 },
      // ÈÖ∏Á¥†„ÅØÁßí„ÅßÁÆ°ÁêÜÔºà„Åì„Åì„ÇíÂ§â„Åà„Çå„Å∞ÊÆã„ÇäÊôÇÈñì„ÅåÂ§â„Çè„ÇãÔºâ
      oxygen: { max: 60 },
      treasure: { spawnInterval: 1200, size: 20, scoreBase: 10, depthBonus: 2 },
      danger: { spawnInterval: 2500, size: 35, speed: 60 },
      surface: { y: 100 }
    };

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    let DPR = Math.max(1, window.devicePixelRatio || 1);
    let W = 0, H = 0, scale = 1;

    const treasureEl = document.getElementById('treasure');
    const depthEl = document.getElementById('depth');
    const oxygenFillEl = document.getElementById('oxygenFill');

    function resize() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const maxW = window.innerWidth, maxH = window.innerHeight;
      const targetRatio = CFG.baseWidth / CFG.baseHeight;
      let cssW, cssH;
      if (maxW / maxH > targetRatio) { cssH = maxH; cssW = Math.round(cssH * targetRatio); }
      else { cssW = maxW; cssH = Math.round(cssW / targetRatio); }
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
      canvas.width = Math.round(cssW * DPR); canvas.height = Math.round(cssH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      W = cssW; H = cssH; scale = W / CFG.baseWidth;
    }
    window.addEventListener('resize', resize);

    // --- „Ç≤„Éº„É†Áä∂ÊÖã ---
    let gameState = 'playing';
    let score = 0, collectedTreasure = 0;
    let oxygen = CFG.oxygen.max; // ÊÆã„ÇäÁßíÊï∞
    let cameraY = 0;
    const player = { x: 0, y: 0, w: 0, h: 0, vx: 0, vy: 0 };
    let treasures = [], dangers = [], particles = [];
    let treasureSpawnTimer = 0, dangerSpawnTimer = 0, lastTime = 0;
    const input = { left: false, right: false, up: false };

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const randFloat = (a, b) => Math.random() * (b - a) + a;
    function rectsOverlap(r1, r2) { return !(r1.x + r1.w <= r2.x || r1.x >= r2.x + r2.w || r1.y + r1.h <= r2.y || r1.y >= r2.y + r2.h); }

    class Bubble {
      constructor(x, y, color = 'rgba(255,255,255,0.6)') { this.x = x; this.y = y; this.size = randFloat(2, 5); this.speedY = randFloat(-40, -80); this.speedX = randFloat(-20, 20); this.life = 1; this.color = color; }
      update(dt) { this.x += this.speedX * dt; this.y += this.speedY * dt; this.life -= dt * 0.8; }
      draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
    }

    function spawnTreasure() {
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      const depthInMeters = Math.floor(depth / scale);
      const value = CFG.treasure.scoreBase + Math.floor(depthInMeters / 100) * CFG.treasure.depthBonus;
      treasures.push({ x: randFloat(0, W - CFG.treasure.size * scale), y: player.y + randFloat(H * 0.3, H * 0.8), w: CFG.treasure.size * scale, h: CFG.treasure.size * scale, value, wobble: Math.random() * Math.PI * 2 });
    }

    function spawnDanger() {
      const fromLeft = Math.random() < 0.5;
      const dir = fromLeft ? 1 : -1;
      dangers.push({ x: fromLeft ? -CFG.danger.size * scale : W + CFG.danger.size * scale, y: player.y + randFloat(H * 0.2, H * 0.7), w: CFG.danger.size * scale, h: CFG.danger.size * scale, vx: dir * CFG.danger.speed * scale, tentacles: Math.random() * Math.PI * 2 });
    }

    // update: ÈÖ∏Á¥†„ÅØÁßí„ÅßÊ∏õ„ÇãÔºàdtÔºâ
    function update(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dtMs = Math.min(50, timestamp - lastTime);
      const dt = dtMs / 1000;
      lastTime = timestamp;

      if (gameState !== 'playing') { draw(); requestAnimationFrame(update); return; }

      // ÁßªÂãï
      const dir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
      player.vx = dir * CFG.player.speed * scale;
      player.x += player.vx * dt;
      player.x = clamp(player.x, 0, W - player.w);

      // ÊµÆ‰∏ä„ÉªÊ≤à‰∏ã
      player.vy = input.up ? -CFG.player.swimUpSpeed * scale : CFG.player.sinkSpeed * scale;
      player.y += player.vy * dt;

      // Ê∞¥Èù¢ÔºöÊµÆ‰∏äÊàêÂäü„Åß„Çπ„Ç≥„Ç¢Á¢∫ÂÆö
      if (player.y <= CFG.surface.y * scale) {
        if (collectedTreasure > 0) { score += collectedTreasure; showMessage('surfaced'); }
        player.y = CFG.surface.y * scale;
      }

      // „Ç´„É°„É©
      const targetCam = Math.max(0, player.y - H * 0.3);
      cameraY += (targetCam - cameraY) * 0.1;

      // === ÈÖ∏Á¥†ÔºàÁ∞°ÊΩîÔºâ ===
      oxygen -= dt; // 1Áßí„Åß1Ê∏õ„Çã
      if (oxygen <= 0) { oxygen = 0; gameState = 'gameover'; showMessage('gameover'); }
      oxygenFillEl.style.width = (oxygen / CFG.oxygen.max * 100) + '%';

      // Ê∑±Â∫¶Ë°®Á§∫Ôºà„É°„Éº„Éà„É´ÊèõÁÆóÔºâ
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      depthEl.textContent = Math.floor(depth / scale);

      // „Çπ„Éù„Éº„É≥
      treasureSpawnTimer += dtMs;
      if (treasureSpawnTimer >= CFG.treasure.spawnInterval) { treasureSpawnTimer = 0; spawnTreasure(); }
      const depthMeters = Math.floor(depth / scale);
      if (depthMeters >= 50) { dangerSpawnTimer += dtMs; if (dangerSpawnTimer >= CFG.danger.spawnInterval) { dangerSpawnTimer = 0; spawnDanger(); } }

      // ÂÆùÂèñÂæó
      treasures.forEach(t => { t.wobble += dt * 3; if (rectsOverlap(player, t)) { collectedTreasure += t.value; treasureEl.textContent = collectedTreasure; t.collected = true; for (let i = 0; i < 8; i++) particles.push(new Bubble(t.x + t.w / 2, t.y + t.h / 2, '#ffd93d')); } });
      treasures = treasures.filter(t => !t.collected && t.y > cameraY - 100 && t.y < cameraY + H + 100);

      // Âç±Èô∫Áâ©Êõ¥Êñ∞
      dangers.forEach(d => { d.x += d.vx * dt; d.tentacles += dt * 4; if (rectsOverlap(player, d)) { gameState = 'gameover'; showMessage('gameover'); } });
      dangers = dangers.filter(d => d.x > -100 && d.x < W + 100 && d.y > cameraY - 100 && d.y < cameraY + H + 100);

      // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´
      particles.forEach(p => p.update(dt));
      particles = particles.filter(p => p.life > 0);
      if (Math.random() < 0.3) particles.push(new Bubble(player.x + player.w / 2, player.y + player.h));

      draw();
      requestAnimationFrame(update);
    }

    function draw() {
      const depth = Math.max(0, player.y - CFG.surface.y * scale);
      const depthRatio = H ? Math.min(1, depth / (H * 3)) : 0;
      const topAlpha = Math.max(0.5, 1 - depthRatio * 0.5);
      const bottomAlpha = Math.max(0.7, 1 - depthRatio * 0.3);
      const gradient = ctx.createLinearGradient(0, 0, 0, H);
      gradient.addColorStop(0, `rgba(135,206,235,${topAlpha})`);
      gradient.addColorStop(1, `rgba(30,58,95,${bottomAlpha})`);
      ctx.fillStyle = gradient; ctx.fillRect(0, 0, W, H);

      ctx.save(); ctx.translate(0, -cameraY);

      // Ê∞¥Èù¢„É©„Ç§„É≥
      ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(0, CFG.surface.y * scale); ctx.lineTo(W, CFG.surface.y * scale); ctx.stroke();
      ctx.fillStyle = 'rgba(135,206,235,0.3)'; ctx.fillRect(0, 0, W, CFG.surface.y * scale);

      // treasures
      treasures.forEach(t => {
        const wobble = Math.sin(t.wobble) * 3;
        ctx.fillStyle = '#ffd93d'; ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(t.x + t.w / 2, t.y + wobble);
        ctx.lineTo(t.x + t.w, t.y + t.h / 2 + wobble); ctx.lineTo(t.x + t.w / 2, t.y + t.h + wobble);
        ctx.lineTo(t.x, t.y + t.h / 2 + wobble); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.font = `${10 * scale}px sans-serif`; ctx.textAlign = 'center';
        ctx.fillText(t.value, t.x + t.w / 2, t.y + t.h / 2 + wobble + 4);
      });

      // dangers
      dangers.forEach(d => {
        ctx.fillStyle = 'rgba(255,107,107,0.7)'; ctx.beginPath();
        ctx.arc(d.x + d.w / 2, d.y + d.h / 3, d.w / 2, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'rgba(255,107,107,0.5)'; ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
          const xOff = (i - 1.5) * d.w / 4; const wave = Math.sin(d.tentacles + i) * 5;
          ctx.beginPath(); ctx.moveTo(d.x + d.w / 2 + xOff, d.y + d.h / 3); ctx.lineTo(d.x + d.w / 2 + xOff + wave, d.y + d.h); ctx.stroke();
        }
      });

      particles.forEach(p => p.draw());

      // player
      ctx.fillStyle = '#4a90e2'; ctx.strokeStyle = '#2c5aa0'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.ellipse(player.x + player.w / 2, player.y + player.h / 2, player.w / 2, player.h / 2, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 3, player.w / 3, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(200,230,255,0.6)'; ctx.beginPath(); ctx.arc(player.x + player.w / 2, player.y + player.h / 3, player.w / 4, 0, Math.PI * 2); ctx.fill();
      const finY = player.y + player.h * 0.8;
      ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.2, finY); ctx.lineTo(player.x, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.3, finY); ctx.fill();
      ctx.beginPath(); ctx.moveTo(player.x + player.w * 0.8, finY); ctx.lineTo(player.x + player.w, finY + player.h * 0.3); ctx.lineTo(player.x + player.w * 0.7, finY); ctx.fill();

      ctx.restore();
    }

    function showMessage(type) {
      const existing = document.querySelector('.message'); if (existing) existing.remove();
      const msg = document.createElement('div'); msg.className = 'message';
      if (type === 'gameover') msg.innerHTML = `<h1>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1><p>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}ÁÇπ</p><p>ÈÖ∏Á¥†„ÅåÂ∞Ω„Åç„Åæ„Åó„Åü...</p><button onclick="restart()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>`;
      else if (type === 'surfaced') msg.innerHTML = `<h1>ÊµÆ‰∏äÊàêÂäüÔºÅ</h1><p>Áç≤Âæó: ${collectedTreasure}ÁÇπ</p><p>ÂêàË®à„Çπ„Ç≥„Ç¢: ${score}ÁÇπ</p><button onclick="continueGame()">ÂÜç„Å≥ÊΩú„Çã</button>`;
      document.body.appendChild(msg);
    }

    // ÂÖ•Âäõ
    window.addEventListener('keydown', (e) => { if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true; if (e.key === 'ArrowRight' || e.key === 'd') input.right = true; if (e.key === 'ArrowUp' || e.key === 'w') input.up = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false; if (e.key === 'ArrowRight' || e.key === 'd') input.right = false; if (e.key === 'ArrowUp' || e.key === 'w') input.up = false; });

    canvas.addEventListener('pointerdown', (e) => { const r = canvas.getBoundingClientRect(); const x = e.clientX - r.left, y = e.clientY - r.top; if (y < r.height / 3) input.up = true; else if (x < r.width / 2) input.left = true; else input.right = true; });
    canvas.addEventListener('pointerup', () => { input.left = false; input.right = false; input.up = false; });
    canvas.addEventListener('pointercancel', () => { input.left = false; input.right = false; input.up = false; });

    function restart() {
      gameState = 'playing'; score = 0; collectedTreasure = 0; oxygen = CFG.oxygen.max; cameraY = 0;
      treasures = []; dangers = []; particles = []; treasureSpawnTimer = 0; dangerSpawnTimer = 0;
      player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
      treasureEl.textContent = '0'; depthEl.textContent = '0'; oxygenFillEl.style.width = '100%';
      const m = document.querySelector('.message'); if (m) m.remove(); lastTime = 0; requestAnimationFrame(update);
    }

    function continueGame() {
      gameState = 'playing'; collectedTreasure = 0; oxygen = CFG.oxygen.max; player.y = CFG.surface.y * scale; player.vx = 0; player.vy = 0;
      treasureEl.textContent = '0'; oxygenFillEl.style.width = '100%'; const m = document.querySelector('.message'); if (m) m.remove(); lastTime = 0;
    }

    function init() {
      resize();
      player.w = CFG.player.w * scale; player.h = CFG.player.h * scale;
      player.x = W / 2 - player.w / 2; player.y = CFG.surface.y * scale;
      treasureEl.textContent = '0'; depthEl.textContent = '0';
      requestAnimationFrame(update);
    }
    init();
  </script>
</body>

</html>