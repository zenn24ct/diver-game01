<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Diver</title>
<style>
  :root{
    --bg1:#1a1a2e;
    --bg2:#16213e;
    --accent:#00f5ff;
    --muted: rgba(255,255,255,0.85);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  html,body{height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN";}
  body{
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:10px;
    color:var(--muted);
    overflow:hidden;
    min-height:100vh;
  }
  .container{
    width:100%;
    height:100%;
    max-width:100vw;
    max-height:100vh;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{
    width:auto;
    height:auto;
    max-width:100%;
    max-height:100%;
    border-radius:20px;
    display:block;
    box-shadow:0 20px 60px rgba(0,0,0,.6);
    background:linear-gradient(to bottom, #1a1a2e 0%, #16213e 100%);
  }
  .overlay{position:relative;margin-top:-100%;pointer-events:none;height:0;}
  .hud{position:relative;pointer-events:none;width:100%;}
  .hud .score{
    position:absolute;
    left:20px;
    top:20px;
    font-weight:700;
    color:#fff;
    font-size:24px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(0,245,255,0.3);
    pointer-events:auto;
  }
  .centerMsg{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    text-align:center;
    pointer-events:auto;
    color:#fff;
    padding:20px 30px;
    border-radius:15px;
    background:rgba(0,0,0,0.7);
    backdrop-filter:blur(10px);
  }
  .centerMsg h1{
    font-size:48px;
    margin-bottom:20px;
    color:#ff6b6b;
    text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
  }
  .centerMsg p{
    font-size:24px;
    margin-bottom:30px;
  }
  .centerMsg button{
    padding:15px 40px;
    font-size:20px;
    background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border:none;
    border-radius:50px;
    color:white;
    cursor:pointer;
    transition:transform 0.2s, box-shadow 0.2s;
    box-shadow:0 5px 15px rgba(0,0,0,0.3);
  }
  .centerMsg button:hover{
    transform:translateY(-2px);
    box-shadow:0 8px 20px rgba(102,126,234,0.4);
  }
  .instructions{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    color:rgba(255,255,255,0.7);
    font-size:16px;
    text-align:center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  }
  @media (max-width:640px){ 
    .centerMsg h1{font-size:32px;}
    .centerMsg p{font-size:18px;}
    .centerMsg button{font-size:16px; padding:12px 30px;}
  }
</style>
</head>
<body>
  <div class="container">
    <canvas id="c"></canvas>
    <div class="overlay" id="overlay">
      <div class="hud" id="hud">
        <div class="score">スコア: <span id="score">0</span></div>
      </div>
      <div class="instructions">← → / A D / タップ で移動</div>
    </div>
  </div>

<script>
/* Neon Diver - ネオンエフェクト統合版 */

const CFG = {
  baseWidth: 480,
  aspect: 10/16,
  player: { w: 40, h: 40, speed: 360, accel: 18, friction: 14 },
  wall: { thickness: 28, baseSpeed: 160 },
  spawnBase: 1100,
  spawnMin: 600,
  holeMin: 64, holeMax: 170,
  gapShrinkRate: 0.45,
  hitboxShrink: 0.78,
  particleCount: 12,
  minVerticalGapBase: 150,
  blockChance: 0.08
};

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

let DPR = Math.max(1, window.devicePixelRatio || 1);
let W=0,H=0,scale=1;

const scoreEl = document.getElementById('score');
const hud = document.getElementById('hud');

let last=0, running=true, score=0, best=0, frameCount=0;
let walls = [];
let blocks = [];
let particles = [];
let trailParticles = [];
let spawnTimer = 0;

const player = { x:0, y:0, w:CFG.player.w, h:CFG.player.h, vx:0, targetDir:0 };
const input = { left:false, right:false };

function resize(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  
  const maxW = window.innerWidth;
  const maxH = window.innerHeight;
  const targetRatio = 10 / 16; // 幅/高さ = 10:16
  
  let cssW, cssH;
  
  // 画面のアスペクト比を計算
  const screenRatio = maxW / maxH;
  
  if (screenRatio > targetRatio) {
    // 画面が横長 → 高さを基準にする
    cssH = maxH;
    cssW = Math.round(cssH * targetRatio);
  } else {
    // 画面が縦長 → 幅を基準にする
    cssW = maxW;
    cssH = Math.round(cssW / targetRatio);
  }
  
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = cssW; H = cssH;
  scale = W / CFG.baseWidth;
  player.y = Math.round(H * 0.25);
  player.w = Math.round(CFG.player.w * scale);
  player.h = Math.round(CFG.player.h * scale);
}
window.addEventListener('resize', resize);

function loadBest(){ try{ best = parseInt(localStorage.getItem('neon-diver-best')||'0',10)||0 }catch(e){ best=0 } }
function saveBest(){ try{ localStorage.setItem('neon-diver-best', String(best)); }catch(e){} }

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function minVerticalGap(){ return Math.round(CFG.minVerticalGapBase * scale); }

// パーティクルクラス（ネオンエフェクト用）
class NeonParticle {
  constructor(x, y, type='normal') {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 3 + 1;
    this.speedX = Math.random() * 3 - 1.5;
    this.speedY = Math.random() * 3 - 1.5;
    this.life = 1;
    this.maxLife = type === 'trail' ? 0.5 : 1;
    this.color = `hsl(${Math.random() * 60 + 180}, 80%, ${60 + Math.random()*20}%)`;
  }
  
  update(dt) {
    this.x += this.speedX;
    this.y += this.speedY;
    this.life -= 0.02 * (dt * 60);
  }
  
  draw() {
    ctx.globalAlpha = this.life;
    ctx.shadowBlur = 10;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
}

function spawn(){
  if (walls.length > 0){
    const lastWall = walls[walls.length - 1];
    const minGap = minVerticalGap();
    if (lastWall.y > H - minGap) return false;
  }

  const r = Math.random();
  let pick;
  if (r < 0.5) pick = 'normal';
  else if (r < 0.8) pick = 'wobble';
  else if (r < 0.96) pick = 'narrow';
  else pick = 'block';

  if (pick === 'block' && Math.random() > CFG.blockChance / 0.08) pick = 'normal';

  if (pick === 'block'){
    const bw = Math.round(rand(48,110) * scale);
    const bh = Math.round(rand(18,36) * scale);
    const y = rand(Math.round(H*0.35), Math.round(H*0.75));
    const fromLeft = Math.random() < 0.5;
    const x = fromLeft ? -bw : W + bw;
    const vx = (fromLeft ? 1 : -1) * (120 + Math.random()*140) * scale;
    blocks.push({ x, y, w: bw, h: bh, vx, passed:false });
    return true;
  }

  const shrink = Math.min(score * CFG.gapShrinkRate, (CFG.holeMax - CFG.holeMin) * 0.85);
  let holeW_base = Math.round(clamp(CFG.holeMax - shrink, CFG.holeMin, CFG.holeMax) * scale);
  if (pick === 'narrow') holeW_base = Math.round(Math.max(CFG.holeMin, holeW_base * 0.62));
  const holeX = rand(8, Math.max(8, W - holeW_base - 8));
  const th = Math.round(CFG.wall.thickness * scale);
  const wall = { y: H + th, holeX, holeW: holeW_base, thickness: th, passed:false, type: pick };

  if (pick === 'wobble'){
    wall.wobbleAmp = Math.max(12, Math.round(28 * scale));
    wall.wobbleSpeed = 0.003 + Math.random()*0.007;
    wall.baseX = wall.holeX;
    wall.phase = Math.random()*1000;
  }

  walls.push(wall);
  return true;
}

function rectsOverlap(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }

function rectCollidesWall(px, py, pw, ph, wall){
  const top = wall.y - wall.thickness;
  const bottom = wall.y;
  if (py + ph <= top || py >= bottom) return false;
  const hbShrink = CFG.hitboxShrink;
  const hhW = Math.round(pw * hbShrink);
  const hhH = Math.round(ph * hbShrink);
  const hx = px + Math.round((pw - hhW)/2);
  const hy = py + Math.round((ph - hhH)/2);

  if (wall.holeX > 0){
    const lw = { x:0, y:top, w:wall.holeX, h:wall.thickness };
    if (rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, lw)) return true;
  }
  const rx = wall.holeX + wall.holeW;
  if (rx < W){
    const rw = { x:rx, y:top, w: W - rx, h: wall.thickness };
    if (rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, rw)) return true;
  }
  return false;
}

function rectCollidesBlock(px,py,pw,ph,block){
  const hbShrink = CFG.hitboxShrink;
  const hhW = Math.round(pw * hbShrink);
  const hhH = Math.round(ph * hbShrink);
  const hx = px + Math.round((pw - hhW)/2);
  const hy = py + Math.round((ph - hhH)/2);
  return rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, {x:block.x,y:block.y,w:block.w,h:block.h});
}

function makeParticles(x,y,count=CFG.particleCount){
  for (let i=0;i<count;i++){
    particles.push(new NeonParticle(x, y, 'normal'));
  }
}

function update(ts){
  if (!last) last = ts;
  const dtMs = Math.min(120, ts - last);
  const dt = dtMs / 1000;
  last = ts;

  if (!running){
    draw(true);
    requestAnimationFrame(update);
    return;
  }

  frameCount++;

  player.targetDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
  const desiredV = player.targetDir * CFG.player.speed * scale;
  player.vx += (desiredV - player.vx) * Math.min(1, CFG.player.accel * dt);
  player.vx -= player.vx * Math.min(1, CFG.player.friction * dt * 0.02);
  player.x += player.vx * dt;
  player.x = clamp(player.x, 0, W - player.w);

  // トレイルパーティクル生成
  if (frameCount % 3 === 0){
    trailParticles.push(new NeonParticle(player.x + player.w/2, player.y + player.h/2, 'trail'));
  }

  const wallSpeed = CFG.wall.baseSpeed * (1 + Math.min(2, score * 0.06)) * scale;
  for (let w of walls){
    w.y -= wallSpeed * dt;
    if (w.type === 'wobble'){
      w.phase += dtMs;
      w.holeX = Math.round(w.baseX + Math.sin(w.phase * w.wobbleSpeed) * w.wobbleAmp);
      w.holeX = clamp(w.holeX, 6, Math.max(6, W - w.holeW - 6));
    }
  }
  for (let b of blocks) b.x += b.vx * dt;

  for (let w of walls){
    if (!w.passed && w.y + 2 < player.y){
      w.passed = true;
      score += 1;
      scoreEl.textContent = score;
      makeParticles(player.x + player.w/2, player.y + player.h/2, 15);
      if (score > best){ best = score; saveBest(); }
    }
  }

  walls = walls.filter(w => w.y > -w.thickness - 8);
  blocks = blocks.filter(b => b.x + b.w > -80 && b.x < W + 80);

  spawnTimer += dtMs;
  const targetInterval = Math.max(CFG.spawnMin, CFG.spawnBase - score * 14);
  if (spawnTimer >= targetInterval){
    spawnTimer = 0;
    spawn();
  }

  for (let b of blocks){
    if (rectCollidesBlock(player.x, player.y, player.w, player.h, b)){
      running = false; draw(true); return;
    }
  }
  for (let w of walls){
    if (rectCollidesWall(player.x, player.y, player.w, player.h, w)){
      running = false; draw(true); return;
    }
  }

  particles.forEach(p => p.update(dt));
  particles = particles.filter(p => p.life > 0);
  trailParticles.forEach(p => p.update(dt));
  trailParticles = trailParticles.filter(p => p.life > 0);

  draw(false);
  requestAnimationFrame(update);
}

function draw(gameOver) {
  ctx.clearRect(0, 0, W, H);

  // 背景グラデーション
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#1a1a2e');
  gradient.addColorStop(1, '#16213e');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);

  // グリッド線（動的）
  ctx.strokeStyle = 'rgba(0, 245, 255, 0.15)';
  ctx.lineWidth = 1;
  for (let i = 0; i < W; i += 50) {
    const offset = (frameCount * 2) % 50;
    ctx.beginPath();
    ctx.moveTo(i - offset, 0);
    ctx.lineTo(i - offset, H);
    ctx.stroke();
  }

  // 壁描画（ネオンエフェクト付き）
  for (let w of walls) {
    const top = w.y - w.thickness;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsl(${Math.random() * 60 + 280}, 80%, 60%)`;
    
    if (w.holeX > 0) {
      ctx.fillStyle = `hsl(${280 + Math.random()*30}, 70%, 55%)`;
      ctx.fillRect(0, top, w.holeX, w.thickness);
    }
    const rx = w.holeX + w.holeW;
    if (rx < W) {
      ctx.fillStyle = `hsl(${280 + Math.random()*30}, 70%, 55%)`;
      ctx.fillRect(rx, top, W - rx, w.thickness);
    }
    ctx.shadowBlur = 0;
  }

  // ブロック描画（ネオンエフェクト付き）
  for (let b of blocks) {
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ff6b6b';
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.shadowBlur = 0;
  }

  // トレイルパーティクル描画
  trailParticles.forEach(p => p.draw());
  
  // パーティクル描画
  particles.forEach(p => p.draw());

  // プレイヤー描画（ネオンキューブ）
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#00f5ff';
  ctx.fillStyle = '#00f5ff';
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.shadowBlur = 0;

  // 目
  ctx.fillStyle = '#fff';
  const eyeSize = Math.round(player.w * 0.2);
  const eyeOffset = Math.round(player.w * 0.2);
  ctx.fillRect(player.x + eyeOffset, player.y + eyeOffset, eyeSize, eyeSize);
  ctx.fillRect(player.x + player.w - eyeOffset - eyeSize, player.y + eyeOffset, eyeSize, eyeSize);

  if (gameOver) {
    handleGameOverDOM(true);
  } else {
    handleGameOverDOM(false);
  }
}

function handleGameOverDOM(gameOver){
  const existing = document.querySelector('.centerMsg');
  if (existing) existing.remove();
  if (!gameOver) return;
  
  const msg = document.createElement('div');
  msg.className = 'centerMsg';
  msg.innerHTML = `
    <h1>ゲームオーバー</h1>
    <p>最終スコア: ${score}</p>
    <button onclick="restart()">リスタート</button>
  `;
  hud.appendChild(msg);
}

window.addEventListener('keydown',(e)=>{
  if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left=true;
  if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right=true;
  if (e.key===' ' && !running) restart();
});
window.addEventListener('keyup',(e)=>{
  if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left=false;
  if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right=false;
});

canvas.addEventListener('pointerdown',(e)=>{
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  if (!running){ restart(); return; }
  if (x < r.width/2) input.left = true; else input.right = true;
});
canvas.addEventListener('pointerup', ()=>{ input.left=false; input.right=false; });
canvas.addEventListener('pointercancel', ()=>{ input.left=false; input.right=false; });

function restart(){
  walls = []; blocks = []; particles = []; trailParticles = [];
  score = 0; spawnTimer = 0; running = true; frameCount = 0;
  player.x = Math.round(W/2 - player.w/2);
  player.vx = 0; scoreEl.textContent = score;
  const ex = document.querySelector('.centerMsg'); if (ex) ex.remove();
  spawn(); setTimeout(()=>spawn(), 360); setTimeout(()=>spawn(), 760);
  last = 0; requestAnimationFrame(update);
}

function init(){
  resize(); loadBest();
  player.x = Math.round(W/2 - player.w/2);
  scoreEl.textContent = score;
  setTimeout(()=>{ spawn(); spawnTimer = -200; }, 120);
  requestAnimationFrame(update);
}
init();
</script>
</body>
</html>
