<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flower Diver</title>
<style>
  :root{
    --bg1:#fff0f5;
    --bg2:#ffe4e8;
    --accent:#ff69b4;
    --muted: rgba(0,0,0,0.7);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  html,body{height:100%;font-family:'Comic Sans MS', 'Arial Rounded MT Bold', system-ui, sans-serif;}
  body{
    background:linear-gradient(135deg, #ffd6e8 0%, #ffb3d9 50%, #ffa0d2 100%);
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0;
    color:var(--muted);
    overflow:hidden;
  }
  .container{
    width:100%;
    height:100%;
    max-width:100vw;
    max-height:100vh;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .canvas-wrapper{
    position:relative;
    display:inline-block;
  }
  canvas{
    width:auto;
    height:auto;
    max-width:100%;
    max-height:100%;
    border-radius:30px;
    display:block;
    box-shadow:0 20px 60px rgba(255,105,180,0.4), 0 0 100px rgba(255,182,193,0.3);
    background:linear-gradient(to bottom, #fff5f8 0%, #ffe8f0 100%);
    border: 4px solid #ffb6d9;
  }
  .overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;}
  .hud{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;}
  .hud .score{
    position:absolute;
    left:20px;
    top:20px;
    font-weight:700;
    color:#ff1493;
    font-size:26px;
    text-shadow: 2px 2px 0px #fff, 3px 3px 0px rgba(255,105,180,0.5);
    pointer-events:auto;
  }
  .centerMsg{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    text-align:center;
    pointer-events:auto;
    color:#fff;
    padding:30px 40px;
    border-radius:25px;
    background:linear-gradient(135deg, #ff8fab 0%, #ffa5c3 100%);
    backdrop-filter:blur(10px);
    box-shadow:0 10px 40px rgba(255,105,180,0.5);
    border: 3px solid #fff;
    min-width:300px;
  }
  .centerMsg h1{
    font-size:48px;
    margin-bottom:20px;
    color:#fff;
    text-shadow: 3px 3px 0px #ff1493, 5px 5px 0px rgba(255,20,147,0.3);
    white-space:nowrap;
  }
  .centerMsg p{
    font-size:24px;
    margin-bottom:30px;
    color:#fff;
    text-shadow: 1px 1px 2px rgba(255,20,147,0.5);
  }
  .centerMsg button{
    padding:15px 40px;
    font-size:22px;
    background:linear-gradient(135deg, #fff 0%, #ffe4f0 100%);
    border:3px solid #ff69b4;
    border-radius:50px;
    color:#ff1493;
    cursor:pointer;
    transition:transform 0.2s, box-shadow 0.2s;
    box-shadow:0 5px 20px rgba(255,105,180,0.4);
    font-weight:bold;
  }
  .centerMsg button:hover{
    transform:translateY(-3px) scale(1.05);
    box-shadow:0 8px 30px rgba(255,105,180,0.6);
  }
  .instructions{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    color:#ff1493;
    font-size:18px;
    text-align:center;
    text-shadow: 1px 1px 0px #fff, 2px 2px 0px rgba(255,105,180,0.3);
    font-weight:bold;
  }
  @media (max-width:640px){ 
    .centerMsg h1{font-size:36px;}
    .centerMsg p{font-size:20px;}
    .centerMsg button{font-size:18px; padding:12px 30px;}
  }
</style>
</head>
<body>
  <div class="container">
    <div class="canvas-wrapper">
      <canvas id="c"></canvas>
      <div class="overlay" id="overlay">
        <div class="hud" id="hud">
          <div class="score">„Çπ„Ç≥„Ç¢: <span id="score">0</span></div>
        </div>
        <div class="instructions">üå∏ ‚Üê ‚Üí / A D / „Çø„ÉÉ„Éó „ÅßÁßªÂãï üå∏</div>
      </div>
    </div>
  </div>

<script>
/* Flower Diver - Ëä±„É¢„ÉÅ„Éº„Éï„ÅÆÂèØÊÑõ„ÅÑ„Ç≤„Éº„É† */

const CFG = {
  baseWidth: 480,
  aspect: 10/16,
  player: { w: 40, h: 40, speed: 360, accel: 18, friction: 14 },
  wall: { thickness: 28, baseSpeed: 160 },
  spawnBase: 1100,
  spawnMin: 600,
  holeMin: 64, holeMax: 170,
  gapShrinkRate: 0.45,
  hitboxShrink: 0.78,
  particleCount: 12,
  minVerticalGapBase: 150,
  blockChance: 0.08
};

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });

let DPR = Math.max(1, window.devicePixelRatio || 1);
let W=0,H=0,scale=1;

const scoreEl = document.getElementById('score');
const hud = document.getElementById('hud');

let last=0, running=true, score=0, best=0, frameCount=0;
let walls = [];
let blocks = [];
let particles = [];
let trailParticles = [];
let spawnTimer = 0;

const player = { x:0, y:0, w:CFG.player.w, h:CFG.player.h, vx:0, targetDir:0 };
const input = { left:false, right:false };

function resize(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  
  const maxW = window.innerWidth;
  const maxH = window.innerHeight;
  const targetRatio = 10 / 16;
  
  let cssW, cssH;
  const screenRatio = maxW / maxH;
  
  if (screenRatio > targetRatio) {
    cssH = maxH;
    cssW = Math.round(cssH * targetRatio);
  } else {
    cssW = maxW;
    cssH = Math.round(cssW / targetRatio);
  }
  
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W = cssW; H = cssH;
  scale = W / CFG.baseWidth;
  player.y = Math.round(H * 0.25);
  player.w = Math.round(CFG.player.w * scale);
  player.h = Math.round(CFG.player.h * scale);
}
window.addEventListener('resize', resize);

function loadBest(){ try{ best = parseInt(localStorage.getItem('flower-diver-best')||'0',10)||0 }catch(e){ best=0 } }
function saveBest(){ try{ localStorage.setItem('flower-diver-best', String(best)); }catch(e){} }

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;

function minVerticalGap(){ return Math.round(CFG.minVerticalGapBase * scale); }

// Ëä±„Å≥„Çâ„Éë„Éº„ÉÜ„Ç£„ÇØ„É´„ÇØ„É©„Çπ
class FlowerParticle {
  constructor(x, y, type='normal') {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 4 + 2;
    this.speedX = Math.random() * 4 - 2;
    this.speedY = Math.random() * 4 - 2;
    this.life = 1;
    this.maxLife = type === 'trail' ? 0.5 : 1;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 0.2;
    const colors = ['#ffb3d9', '#ff8fab', '#ffa5c3', '#ff69b4', '#ffc0e3'];
    this.color = colors[Math.floor(Math.random() * colors.length)];
  }
  
  update(dt) {
    this.x += this.speedX;
    this.y += this.speedY;
    this.rotation += this.rotationSpeed;
    this.life -= 0.015 * (dt * 60);
  }
  
  draw() {
    ctx.save();
    ctx.globalAlpha = this.life;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    
    // Ëä±„Å≥„ÇâÊèèÁîª
    for (let i = 0; i < 5; i++) {
      ctx.rotate(Math.PI * 2 / 5);
      ctx.beginPath();
      ctx.ellipse(0, -this.size, this.size * 0.5, this.size, 0, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
    }
    
    // ‰∏≠ÂøÉ„ÅÆÈªÑËâ≤„ÅÑÈÉ®ÂàÜ
    ctx.beginPath();
    ctx.arc(0, 0, this.size * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = '#fff9b3';
    ctx.fill();
    
    ctx.restore();
    ctx.globalAlpha = 1;
  }
}

function spawn(){
  if (walls.length > 0){
    const lastWall = walls[walls.length - 1];
    const minGap = minVerticalGap();
    if (lastWall.y > H - minGap) return false;
  }

  const r = Math.random();
  let pick;
  if (r < 0.5) pick = 'normal';
  else if (r < 0.8) pick = 'wobble';
  else if (r < 0.96) pick = 'narrow';
  else pick = 'block';

  if (pick === 'block' && Math.random() > CFG.blockChance / 0.08) pick = 'normal';

  if (pick === 'block'){
    const bw = Math.round(rand(48,110) * scale);
    const bh = Math.round(rand(18,36) * scale);
    const y = rand(Math.round(H*0.35), Math.round(H*0.75));
    const fromLeft = Math.random() < 0.5;
    const x = fromLeft ? -bw : W + bw;
    const vx = (fromLeft ? 1 : -1) * (120 + Math.random()*140) * scale;
    blocks.push({ x, y, w: bw, h: bh, vx, passed:false });
    return true;
  }

  const shrink = Math.min(score * CFG.gapShrinkRate, (CFG.holeMax - CFG.holeMin) * 0.85);
  let holeW_base = Math.round(clamp(CFG.holeMax - shrink, CFG.holeMin, CFG.holeMax) * scale);
  if (pick === 'narrow') holeW_base = Math.round(Math.max(CFG.holeMin, holeW_base * 0.62));
  const holeX = rand(8, Math.max(8, W - holeW_base - 8));
  const th = Math.round(CFG.wall.thickness * scale);
  const wall = { y: H + th, holeX, holeW: holeW_base, thickness: th, passed:false, type: pick };

  if (pick === 'wobble'){
    wall.wobbleAmp = Math.max(12, Math.round(28 * scale));
    wall.wobbleSpeed = 0.003 + Math.random()*0.007;
    wall.baseX = wall.holeX;
    wall.phase = Math.random()*1000;
  }

  walls.push(wall);
  return true;
}

function rectsOverlap(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }

function rectCollidesWall(px, py, pw, ph, wall){
  const top = wall.y - wall.thickness;
  const bottom = wall.y;
  if (py + ph <= top || py >= bottom) return false;
  const hbShrink = CFG.hitboxShrink;
  const hhW = Math.round(pw * hbShrink);
  const hhH = Math.round(ph * hbShrink);
  const hx = px + Math.round((pw - hhW)/2);
  const hy = py + Math.round((ph - hhH)/2);

  if (wall.holeX > 0){
    const lw = { x:0, y:top, w:wall.holeX, h:wall.thickness };
    if (rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, lw)) return true;
  }
  const rx = wall.holeX + wall.holeW;
  if (rx < W){
    const rw = { x:rx, y:top, w: W - rx, h: wall.thickness };
    if (rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, rw)) return true;
  }
  return false;
}

function rectCollidesBlock(px,py,pw,ph,block){
  const hbShrink = CFG.hitboxShrink;
  const hhW = Math.round(pw * hbShrink);
  const hhH = Math.round(ph * hbShrink);
  const hx = px + Math.round((pw - hhW)/2);
  const hy = py + Math.round((ph - hhH)/2);
  return rectsOverlap({x:hx,y:hy,w:hhW,h:hhH}, {x:block.x,y:block.y,w:block.w,h:block.h});
}

function makeParticles(x,y,count=CFG.particleCount){
  for (let i=0;i<count;i++){
    particles.push(new FlowerParticle(x, y, 'normal'));
  }
}

function update(ts){
  if (!last) last = ts;
  const dtMs = Math.min(120, ts - last);
  const dt = dtMs / 1000;
  last = ts;

  if (!running){
    draw(true);
    requestAnimationFrame(update);
    return;
  }

  frameCount++;

  player.targetDir = (input.left ? -1 : 0) + (input.right ? 1 : 0);
  const desiredV = player.targetDir * CFG.player.speed * scale;
  player.vx += (desiredV - player.vx) * Math.min(1, CFG.player.accel * dt);
  player.vx -= player.vx * Math.min(1, CFG.player.friction * dt * 0.02);
  player.x += player.vx * dt;
  player.x = clamp(player.x, 0, W - player.w);

  // „Éà„É¨„Ç§„É´„Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÁîüÊàê
  if (frameCount % 3 === 0){
    trailParticles.push(new FlowerParticle(player.x + player.w/2, player.y + player.h/2, 'trail'));
  }

  const wallSpeed = CFG.wall.baseSpeed * (1 + Math.min(2, score * 0.06)) * scale;
  for (let w of walls){
    w.y -= wallSpeed * dt;
    if (w.type === 'wobble'){
      w.phase += dtMs;
      w.holeX = Math.round(w.baseX + Math.sin(w.phase * w.wobbleSpeed) * w.wobbleAmp);
      w.holeX = clamp(w.holeX, 6, Math.max(6, W - w.holeW - 6));
    }
  }
  for (let b of blocks) b.x += b.vx * dt;

  for (let w of walls){
    if (!w.passed && w.y + 2 < player.y){
      w.passed = true;
      score += 1;
      scoreEl.textContent = score;
      makeParticles(player.x + player.w/2, player.y + player.h/2, 20);
      if (score > best){ best = score; saveBest(); }
    }
  }

  walls = walls.filter(w => w.y > -w.thickness - 8);
  blocks = blocks.filter(b => b.x + b.w > -80 && b.x < W + 80);

  spawnTimer += dtMs;
  const targetInterval = Math.max(CFG.spawnMin, CFG.spawnBase - score * 14);
  if (spawnTimer >= targetInterval){
    spawnTimer = 0;
    spawn();
  }

  for (let b of blocks){
    if (rectCollidesBlock(player.x, player.y, player.w, player.h, b)){
      running = false; draw(true); return;
    }
  }
  for (let w of walls){
    if (rectCollidesWall(player.x, player.y, player.w, player.h, w)){
      running = false; draw(true); return;
    }
  }

  particles.forEach(p => p.update(dt));
  particles = particles.filter(p => p.life > 0);
  trailParticles.forEach(p => p.update(dt));
  trailParticles = trailParticles.filter(p => p.life > 0);

  draw(false);
  requestAnimationFrame(update);
}

// Ëä±„ÇíÊèè„ÅèÈñ¢Êï∞
function drawFlower(x, y, size, color, centerColor) {
  ctx.save();
  ctx.translate(x, y);
  
  // Ëä±„Å≥„Çâ
  for (let i = 0; i < 5; i++) {
    ctx.rotate(Math.PI * 2 / 5);
    ctx.beginPath();
    ctx.ellipse(0, -size * 0.6, size * 0.4, size * 0.6, 0, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  // ‰∏≠ÂøÉ
  ctx.beginPath();
  ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
  ctx.fillStyle = centerColor;
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.restore();
}

function draw(gameOver) {
  ctx.clearRect(0, 0, W, H);

  // ËÉåÊôØ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  gradient.addColorStop(0, '#fff5f8');
  gradient.addColorStop(0.5, '#ffe8f0');
  gradient.addColorStop(1, '#ffd6e8');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);

  // ËÉåÊôØ„ÅÆËä±Ê®°Êßò
  ctx.globalAlpha = 0.1;
  for (let i = 0; i < 8; i++) {
    const x = (i * W / 8 + frameCount * 0.5) % W;
    const y = (frameCount * 0.3 + i * 80) % H;
    drawFlower(x, y, 20 * scale, '#ffb3d9', '#fff9b3');
  }
  ctx.globalAlpha = 1;

  // Â£ÅÊèèÁîªÔºàËä±ÊüÑÔºâ
  for (let w of walls) {
    const top = w.y - w.thickness;
    
    // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
    const wallGrad = ctx.createLinearGradient(0, top, 0, top + w.thickness);
    wallGrad.addColorStop(0, '#ff8fab');
    wallGrad.addColorStop(1, '#ffb3d9');
    
    if (w.holeX > 0) {
      ctx.fillStyle = wallGrad;
      ctx.fillRect(0, top, w.holeX, w.thickness);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(0, top, w.holeX, w.thickness);
    }
    const rx = w.holeX + w.holeW;
    if (rx < W) {
      ctx.fillStyle = wallGrad;
      ctx.fillRect(rx, top, W - rx, w.thickness);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 3;
      ctx.strokeRect(rx, top, W - rx, w.thickness);
    }
  }

  // „Éñ„É≠„ÉÉ„ÇØÊèèÁîªÔºà„Éè„Éº„ÉàÂûãÔºâ
  for (let b of blocks) {
    ctx.save();
    ctx.translate(b.x + b.w/2, b.y + b.h/2);
    const size = Math.min(b.w, b.h) / 2;
    
    // „Éè„Éº„ÉàÊèèÁîª
    ctx.beginPath();
    ctx.moveTo(0, size * 0.3);
    ctx.bezierCurveTo(-size, -size * 0.3, -size * 1.5, size * 0.5, 0, size * 1.2);
    ctx.bezierCurveTo(size * 1.5, size * 0.5, size, -size * 0.3, 0, size * 0.3);
    ctx.fillStyle = '#ff6b9d';
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.restore();
  }

  // „Éà„É¨„Ç§„É´„Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÊèèÁîª
  trailParticles.forEach(p => p.draw());
  
  // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÊèèÁîª
  particles.forEach(p => p.draw());

  // „Éó„É¨„Ç§„É§„ÉºÊèèÁîªÔºàÂ§ß„Åç„Å™Ëä±Ôºâ
  const centerX = player.x + player.w / 2;
  const centerY = player.y + player.h / 2;
  const flowerSize = player.w * 0.5;
  
  drawFlower(centerX, centerY, flowerSize, '#ff69b4', '#fff9b3');
  


  if (gameOver) {
    handleGameOverDOM(true);
  } else {
    handleGameOverDOM(false);
  }
}

function handleGameOverDOM(gameOver){
  const existing = document.querySelector('.centerMsg');
  if (existing) existing.remove();
  if (!gameOver) return;
  
  const msg = document.createElement('div');
  msg.className = 'centerMsg';
  msg.innerHTML = `
    <h1>üå∏ „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº üå∏</h1>
    <p>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}</p>
    <button onclick="restart()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÔºÅ</button>
  `;
  hud.appendChild(msg);
}

window.addEventListener('keydown',(e)=>{
  if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left=true;
  if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right=true;
  if (e.key===' ' && !running) restart();
});
window.addEventListener('keyup',(e)=>{
  if (e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left=false;
  if (e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right=false;
});

canvas.addEventListener('pointerdown',(e)=>{
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  if (!running){ restart(); return; }
  if (x < r.width/2) input.left = true; else input.right = true;
});
canvas.addEventListener('pointerup', ()=>{ input.left=false; input.right=false; });
canvas.addEventListener('pointercancel', ()=>{ input.left=false; input.right=false; });

function restart(){
  walls = []; blocks = []; particles = []; trailParticles = [];
  score = 0; spawnTimer = 0; running = true; frameCount = 0;
  player.x = Math.round(W/2 - player.w/2);
  player.vx = 0; scoreEl.textContent = score;
  const ex = document.querySelector('.centerMsg'); if (ex) ex.remove();
  spawn(); setTimeout(()=>spawn(), 360); setTimeout(()=>spawn(), 760);
  last = 0; requestAnimationFrame(update);
}

function init(){
  resize(); loadBest();
  player.x = Math.round(W/2 - player.w/2);
  scoreEl.textContent = score;
  setTimeout(()=>{ spawn(); spawnTimer = -200; }, 120);
  requestAnimationFrame(update);
}
init();
</script>
</body>
</html>
